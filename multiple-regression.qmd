# Multiple Regression {#sec-multipleRegression}

## Getting Started {#sec-multipleRegressionGettingStarted}

### Load Packages {#sec-multipleRegressionLoadPackages}

```{r}
library("petersenlab")
library("rms")
library("car")
library("caret")
library("lme4")
library("performance")
library("lavaan")
library("mice")
library("miceadds")
library("interactions")
library("brms")
library("tidyverse")
library("knitr")
```

### Load Data {#sec-correlationLoadData}

```{r}
#| eval: false
#| include: false

load(file = file.path(path, "/OneDrive - University of Iowa/Teaching/Courses/Fantasy Football/Data/player_stats_weekly.RData", fsep = ""))
load(file = file.path(path, "/OneDrive - University of Iowa/Teaching/Courses/Fantasy Football/Data/player_stats_seasonal.RData", fsep = ""))
```

```{r}
load(file = "./data/player_stats_weekly.RData")
load(file = "./data/player_stats_seasonal.RData")
```

We created the `player_stats_weekly.RData` and `player_stats_seasonal.RData` objects in @sec-calculatePlayerAge.

## Overview of Multiple Regression {#sec-multipleRegressionOverview}

Multiple regression is an extension of [correlation](#sec-correlation).
[Correlation](#sec-correlation) examines the association between one [predictor variables](#sec-correlationalStudy) and one [outcome variable](#sec-correlationalStudy).
Multiple regression examines the association between *multiple* [predictor variables](#sec-correlationalStudy) and one [outcome variable](#sec-correlationalStudy).
It allows obtaining a more accurate estimate of the unique contribution of a given [predictor variable](#sec-correlationalStudy), by controlling for other variables ([covariates](#sec-covariates)).

Regression with one [predictor variable](#sec-correlationalStudy) takes the form of @eq-regression:

$$
y = \beta_0 + \beta_1x_1 + \epsilon
$$ {#eq-regression}

where $y$ is the [outcome variable](#sec-correlationalStudy), $\beta_0$ is the intercept, $\beta_1$ is the slope, $x_1$ is the [predictor variable](#sec-correlationalStudy), and $\epsilon$ is the error term.

A regression line is depicted in @fig-regression.

```{r}
#| include: false
#| eval: false

set.seed(52242)
regression <- data.frame(outcome = rnorm(40, mean = 5, sd = 2))

regression$predictor <- complement(regression$outcome, .5)
regression$predictor <- regression$predictor + abs(min(regression$predictor))

lm(
  outcome ~ predictor,
  data = regression)

ggplot2::ggplot(
  data = regression,
  aes(
    x = predictor,
    y = outcome,
  )
) +
  geom_point() +
  geom_smooth(
    method = "lm",
    linewidth = 2,
    se = FALSE,
    fullrange = TRUE) +
  scale_x_continuous(
    lim = c(0,8),
    breaks = seq(from = 0, to = 8, by = 2),
    expand = c(0,0)
  ) +
  scale_y_continuous(
    lim = c(0,8),
    breaks = seq(from = 0, to = 8, by = 2),
    expand = c(0,0)
  ) +
  labs(
    x = "Predictor Variable",
    y = "Outcome Variable",
    title = "Regression Best-Fit Line"
  ) +
  theme_classic(
    base_size = 16) +
  theme(legend.title = element_blank())

ggsave("./images/regression.pdf", width = 6, height = 6)
```

::: {#fig-regression}
![](images/regression.png){fig-alt="A Regression Best-Fit Line."}

A Regression Best-Fit Line.
:::

Regression with multiple predictors—i.e., multiple regression—takes the form of @eq-multipleRegression:

$$
y = \beta_0 + \beta_1x_1 + \beta_2x_2 + ... + \beta_px_p + \epsilon
$$ {#eq-multipleRegression}

where $p$ is the number of [predictor variables](#sec-correlationalStudy).

## Components {#sec-multipleRegressionComponents}

- $B$ = unstandardized coefficient: direction and magnitude of the estimate (original scale)
- $\beta$ (beta) = standardized coefficient: direction and magnitude of the estimate (standard deviation scale)
- $SE$ = standard error: uncertainty of unstandardized estimate

The unstandardized regression coefficient ($B$) is interpreted such that, for every unit change in the [predictor variable](#sec-correlationalStudy), there is a __ unit change in the [outcome variable](#sec-correlationalStudy).
For instance, when examining the association between age and fantasy points, if the unstandardized regression coefficient is 2.3, players score on average 2.3 more points for each additional year of age.
(In reality, we might expect a nonlinear, inverted-U-shaped association between age and fantasy points such that players tend to reach their peak in the middle of their careers.)
Unstandardized regression coefficients are tied to the metric of the raw data.
Thus, a large unstandardized regression coefficient for two variables may mean completely different things.
Holding the strength of the association constant, you tend to see larger unstandardized regression coefficients for variables with smaller units and smaller unstandardized regression coefficients for variables with larger units.

Standardized regression coefficients can be obtained by standardizing the variables to [*z*-scores](#sec-zScores) so they all have a mean of zero and standard deviation of one.
The standardized regression coefficient ($\beta$) is interpreted such that, for every standard deviation change in the [predictor variable](#sec-correlationalStudy), there is a __ standard deviation change in the [outcome variable](#sec-correlationalStudy).
For instance, when examining the association between age and fantasy points, if the standardized regression coefficient is 0.1, players score on average 0.1 standard deviation more points for each additional standard deviation of their year of age.
Standardized regression coefficients—though not the case in all instances—tend to fall between [−1, 1].
Thus, standardized regression coefficients tend to be more comparable across variables and models compared to unstandardized regression coefficients.
In this way, standardized regression coefficients provide a meaningful index of [effect size](#sec-practicalSignificance).

The *standard error* of a regression coefficient represents the uncertainty of the parameter.
If we have less uncertainty (i.e., more confidence) about the parameter, the standard error will be small.
If we have more uncertainty (i.e., less confidence) about the parameter, the standard error will be large.
If we used the same sampling procedure repeatedly and calculated the regression coefficient each time, the true parameter in the population would fall 68% of the time within the interval of:  $[\text{model parameter estimate for the regression coefficient} \pm 1 \text{ standard error}]$ .

A *confidence interval* represents a range of plausible values such that, with repeated sampling, the true value falls within a given interval with some confidence.
Our parameter estimate for the regression coefficient, plus or minus 1 standard error, reflects the 68% confidence interval for the coefficient.
The 95% confidence interval is computed as the parameter estimated plus or minus 1.96 standard errors.
For instance, if the parameter estimate for the regression coefficient is 0.50, and the standard error is 0.10, the 95% confidence interval is [0.30, 0.70]: $0.5 - (1.96 \times 0.10) = 0.3$; $0.5 + (1.96 \times 0.10) = 0.7$.
That is, if we used the same sample procedure repeatedly, the true value of the regression coefficient would be expected to be 95% of the time somewhere between 0.30 to 0.70.

## Assumptions of Multiple Regression {#sec-assumptionsRegression}

Linear regression models make the following assumptions:

- there is a linear association between the predictor variables and the outcome variable
- there is homoscedasticity of the residuals; the residuals do not differ as a function of the predictor variables or as a function of the outcome variable
- the residuals are independent; they are uncorrelated with each other
- the residuals are normally distributed

Homoscedasticity of the residuals means that the variance of the residuals does not differ as a function of the outcome variable or as a function of the predictor variables (i.e., the residuals show constant variance as a function of outcome/predictors).

### Evaluating Assumptions of Multiple Regression {#sec-assumptionsRegressionEvaluating}

To evaluate the shape of the association between the predictor variables and the outcome variable, we can examine scatterplots, residual plots, marginal model plots, and added-variable plots.

To evaluate homoscedasticity, we can evaluate residual plots (@fig-residualPlots).
In residual plots, homoscedasticity is identified as a constant spread of residuals versus fitted values—the residuals do not show a fan or cone shape.

To determine if residuals are correlated by a grouping level, we can examine the proportion of variance that is attributable to the grouping level using the intraclass correlation coefficient (ICC) from a [mixed model](#sec-mixedModels).
The greater the ICC value, the more variance is accounted for by the grouping level, and the more the residuals are intercorrelated.

We can examine whether residuals are normally distributed using quantile–quantile (QQ) plots and probability–probability (PP) plots.
If the residuals are normally distributed, they should stay close to the diagonal reference line.

## Coefficient of Determination ($R^2$) {#sec-multipleRegressionRSquared}

As noted in @sec-statisticalTestsPartitionedVariance, 
The coefficient of determination ($R^2$) reflects the proportion of variance in the [outcome (dependent) variable](#sec-correlationalStudy) that is explained by the model predictions, as in @eq-coefficientOfDeterminationPartitionedVariance: $R^2 = \frac{\text{variance explained in }Y}{\text{total variance in }Y}$.
Various formulas for $R^2$ are in @eq-rSquared.
Larger $R^2$ values indicate greater accuracy.
Multiple regression can be conceptualized with overlapping circles (similar to a venn diagram), where the non-overlapping portions of the circles reflect nonshared variance and the overlapping portions of the circles reflect shared variance, as in @fig-regression.

::: {#fig-regression}
![](images/multipleRegressionRSquared.png){width=50% fig-alt="Conceptual Depiction of Proportion of Variance Explained ($R^2$) in an Outcome Variable ($Y$) by Multiple Predictors ($X1$ and $X2$) in Multiple Regression. The size of each circle represents the variable's variance. The proportion of variance in $Y$ that is explained by the predictors is depicted by the areas in orange. The dark orange space ($G$) is where multiple predictors explain overlapping variance in the outcome. Overlapping variance that is explained in the outcome ($G$) will not be recovered in the regression coefficients when both predictors are included in the regression model. From @Petersen2024a and @PetersenPrinciplesPsychAssessment."}

Conceptual Depiction of Proportion of Variance Explained ($R^2$) in an Outcome Variable ($Y$) by Multiple Predictors ($X1$ and $X2$) in Multiple Regression. The size of each circle represents the variable's variance. The proportion of variance in $Y$ that is explained by the predictors is depicted by the areas in orange. The dark orange space ($G$) is where multiple predictors explain overlapping variance in the outcome. Overlapping variance that is explained in the outcome ($G$) will not be recovered in the regression coefficients when both predictors are included in the regression model. From @Petersen2024a and @PetersenPrinciplesPsychAssessment.
:::

One issue with $R^2$ is that it increases as the number of predictors increases, which can lead to [overfitting](#sec-overfitting) if using $R^2$ as an index to compare models for purposes of selecting the "best-fitting" model.
Consider the following example (adapted from @PetersenPrinciplesPsychAssessment) in which you have one [predictor variable](#sec-correlationalStudy) and one [outcome variable](#sec-correlationalStudy), as shown in @tbl-regression1.

```{r}
#| echo: false

regression1 <- data.frame(
  "y" = c(7, 13, 29, 10),
  "x1" = c(1, 2, 7, 2))

regression2 <- data.frame(
  "y" = c(7, 13, 29, 10),
  "x1" = c(1, 2, 7, 2),
  "x2" = c(3, 5, 1, 2))

regression1_model <- lm(
  y ~ x1,
  data = regression1)

regression1_intercept <- apa(regression1_model$coefficients[[1]], decimals = 2)
regression1_slope <- apa(regression1_model$coefficients[[2]], decimals = 2)
regression1_rsquare <- apa(summary(regression1_model)$r.squared, decimals = 2)

regression2_model <- lm(y ~ x1 + x2, data = regression2)
regression2_intercept <- apa(regression2_model$coefficients[[1]], decimals = 2)
regression2_slope1 <- apa(regression2_model$coefficients[[2]], decimals = 2)
regression2_slope2 <- apa(regression2_model$coefficients[[3]], decimals = 2)
regression2_rsquare <- apa(summary(regression2_model)$r.squared, decimals = 2)
```

```{r}
#| label: tbl-regression1
#| tbl-cap: "Example Data of Predictor (x1) and Outcome (y) Used for Regression Model."
#| echo: false

kable(
  regression1,
  col.names = c("y","x1"),
  booktabs = TRUE)
```

Using the data, the best fitting regression model is: $y =$ `{r} regression1_intercept` $+$ `{r} regression1_slope` $\cdot x_1$.
In this example, the $R^2$ is `{r} regression1_rsquare`.
The equation is not a perfect prediction, but with a single [predictor variable](#sec-correlationalStudy), it captures the majority of the variance in the outcome.

Now consider the following example where you add a second [predictor variable](#sec-correlationalStudy) to the data above, as shown in @tbl-regression2.

```{r}
#| label: tbl-regression2
#| tbl-cap: "Example Data of Predictors (x1 and x2) and Outcome (y) Used for Regression Model."
#| echo: false

kable(
  regression2,
  col.names = c("y","x1","x2"),
  booktabs = TRUE)
```

With the second [predictor variable](#sec-correlationalStudy), the best fitting regression model is: $y =$ `{r} regression2_intercept` + `{r} regression2_slope1` $\cdot x_1 +$ `{r} regression2_slope2` $\cdot x_2$.
In this example, the $R^2$ is `{r} regression2_rsquare`.
The equation with the second [predictor variable](#sec-correlationalStudy) provides a perfect prediction of the outcome.

Providing perfect prediction with the right set of [predictor variable](#sec-correlationalStudy)s is the dream of multiple regression.
So, using multiple regression, we often add [predictor variables](#sec-correlationalStudy) to incrementally improve prediction.
Knowing how much variance would be accounted for by random chance follows @eq-predictionByChance:

$$
E(R^2) = \frac{K}{n-1}
$$ {#eq-predictionByChance}

where $E(R^2)$ is the expected value of $R^2$ (the proportion of variance explained), $K$ is the number of [predictor variables](#sec-correlationalStudy), and $n$ is the sample size.
The formula demonstrates that the more [predictor variables](#sec-correlationalStudy) in the regression model, the more variance will be accounted for by chance.
With many [predictor variables](#sec-correlationalStudy) and a small sample, you can account for a large share of the variance merely by chance.

As an example, consider that we have 13 [predictor variables](#sec-correlationalStudy) to predict fantasy performance for 43 players.
Assume that, with 13 [predictor variables](#sec-correlationalStudy), we explain 38% of the variance ($R^2 = .38; r = .62$).
We explained a lot of the variance in the outcome, but it is important to consider how much variance could have been explained by random chance: $E(R^2) = \frac{K}{n-1} = \frac{13}{43 - 1} = .31$.
We expect to explain 31% of the variance, by chance, in the outcome.
So, 82% of the variance explained was likely spurious (i.e., $\frac{.31}{.38} = .82$).
As the sample size increases, the spuriousness decreases.

To account for the number of [predictor variables](#sec-correlationalStudy) in the model, we can use a modified version of $R^2$ called adjusted $R^2$ ($R^2_{adj}$).
Adjusted $R^2$ ($R^2_{adj}$) accounts for the number of [predictor variables](#sec-correlationalStudy) in the model, based on how much would be expected to be accounted for by chance to penalize [overfitting](#sec-overfitting).
Adjusted $R^2$ ($R^2_{adj}$) reflects the proportion of variance in the [outcome (dependent) variable](#sec-correlationalStudy) that is explained by the model predictions over and above what would be expected to be accounted for by chance, given the number of [predictor variables](#sec-correlationalStudy) in the model.
The formula for adjusted $R^2$ ($R^2_{adj}$) is in @eq-adjustedRSquared:

$$
R^2_{adj} = 1 - (1 - R^2) \frac{n - 1}{n - p - 1}
$$ {#eq-adjustedRSquared}

where $p$ is the number of [predictor variables](#sec-correlationalStudy) in the model, and $n$ is the sample size.

## Overfitting {#sec-overfitting}

Statistical models applied to big data (e.g., data with many [predictor variables](#sec-correlationalStudy)) can *overfit* the data, which means that the statistical model accounts for error variance, which will not generalize to future samples.
So, even though an overfitting statistical model appears to be accurate because it is accounting for more variance, it is not actually that accurate—it will predict new data less accurately than how accurately it accounts for the data with which the model was built.
In the case of fantasy football analytics, this is especially relevant because there are hundreds if not thousands of variables we could consider for inclusion and many, many players when considering historical data.

Consider an example where you develop an algorithm to predict players' fantasy performance based on 2024 data using hundreds of [predictor variables](#sec-correlationalStudy).
To some extent, these [predictor variables](#sec-correlationalStudy) will likely account for true variance (i.e., signal) and error variance (i.e., noise).
If we were to apply the same algorithm based on the `r as.integer(format(Sys.Date(), "%Y")) - 1` prediction model to `r as.integer(format(Sys.Date(), "%Y"))` data, the prediction model would likely predict less accurately than with `r as.integer(format(Sys.Date(), "%Y")) - 1` data.
The regression coefficients tend to become weaker when applied to new data, a phenomenon called [shrinkage](#sec-shrinkage), which is described in @sec-shrinkage.
The regression coefficients in the [FILL IN]

In @fig-overfittingModel, the blue line represents the true distribution of the data, and the red line is an overfitting model:

```{r}
#| label: fig-overfittingModel
#| fig-cap: "Over-fitting Model in Red Relative to the True Distribution of the Data in Blue. From @Petersen2024a and @PetersenPrinciplesPsychAssessment."
#| fig-alt: "Over-fitting Model in Red Relative to the True Distribution of the Data in Blue. From @Petersen2024a and @PetersenPrinciplesPsychAssessment."
#| code-fold: true

set.seed(52242)

sampleSize <- 200
quadraticX <- rnorm(sampleSize)
quadraticY <- quadraticX ^ 2 + rnorm(sampleSize)
quadraticData <- cbind(quadraticX, quadraticY) %>%
  data.frame %>%
  arrange(quadraticX)

quadraticModel <- lm(
  quadraticY ~ quadraticX + I(quadraticX ^ 2),
  data = quadraticData)

quadraticNewData <- data.frame(
  quadraticX = seq(
    from = min(quadraticData$quadraticX),
    to = max(quadraticData$quadraticY),
    length.out = sampleSize))

quadraticNewData$quadraticY <- predict(
  quadraticModel,
  newdata = quadraticNewData)

loessFit <- loess(
  quadraticY ~ quadraticX,
  data = quadraticData,
  span = 0.01,
  degree = 1)

loessNewData <- data.frame(
  quadraticX = seq(
    from = min(quadraticData$quadraticX),
    to = max(quadraticData$quadraticY),
    length.out = sampleSize))

quadraticNewData$loessY <- predict(
  loessFit,
  newdata = quadraticNewData)

plot(
  x = quadraticData$quadraticX,
  y = quadraticData$quadraticY,
  xlab = "",
  ylab = "")

lines(
  quadraticNewData$quadraticY ~ quadraticNewData$quadraticX,
  lwd = 2,
  col = "blue")

lines(
  quadraticNewData$loessY ~ quadraticNewData$quadraticX,
  lwd = 2,
  col = "red")
```

## Covariates {#sec-covariates}

Covariates are variables that you include in the statistical model to try to control for them so you can better isolate the unique contribution of the [predictor variable](#sec-correlationalStudy)(s) in relation to the [outcome variable](#sec-correlationalStudy).
Use of covariates examines the association between the [predictor variable](#sec-correlationalStudy) and the [outcome variable](#sec-correlationalStudy) when holding people's level constant on the covariates.
Inclusion of [confounds](#sec-causalDiagramConfounding) as covariates allows potentially gaining a more accurate estimate of the causal effect of the [predictor variable](#sec-correlationalStudy) on the [outcome variable](#sec-correlationalStudy).
Ideally, you want to include any and all [confounds](#sec-causalDiagramConfounding) as covariates.
As described in @sec-correlationCausation, [confounds](#sec-causalDiagramConfounding) are third variables that influence both the [predictor variable](#sec-correlationalStudy) and the [outcome variable](#sec-correlationalStudy) and explain their association.
Covariates are potentially (but not necessarily) [confounds](#sec-causalDiagramConfounding).
For instance, you might include the player's age as a covariate in a model that examines whether a player's 40-yard dash time at the NFL Combine predicts their fantasy points in their rookie year, but it may not be a [confound](#sec-causalDiagramConfounding).

## Examples {#sec-multipleRegressionExamples}

Let's say we want to use a number of variables to predict a wide receiver's fantasy performance.
We want to consider several predictors, including the player's age, height, weight, and target share.
We have only a few predictors and our sample size is large enough such that [overfitting](#sec-overfitting) is not likely a concern.

Let's first examine the bivariate association of each using a scatterplot to evaluate for any potential nonlinearity, as depicted in @fig-scatterplots.

```{r}
#| layout-ncol: 2
#| label: fig-scatterplots
#| fig-cap: "Scatterplots With Fantasy Points (Season) Among Wide Receivers. The linear best-fit line is in black. The nonlinear best-fit line is in blue."
#| fig-alt: "Scatterplots With Fantasy Points (Season) Among Wide Receivers. The linear best-fit line is in black. The nonlinear best-fit line is in blue."
#| fig-subcap:
#|   - "Age"
#|   - "Height"
#|   - "Weight"
#|   - "Target Share"

ggplot2::ggplot(
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  aes(
    x = age,
    y = fantasyPoints)) +
  geom_point(alpha = 0.05) +
  geom_smooth(
    method = "lm",
    color = "black") +
  geom_smooth() +
  coord_cartesian(
    ylim = c(0,NA),
    expand = FALSE) +
  labs(
    x = "Player Age (Years)",
    y = "Fantasy Points (Season)",
    title = "Fantasy Points (Season) by Player Age",
    subtitle = "(Among Wide Receivers)"
  ) +
  theme_classic()

ggplot2::ggplot(
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  aes(
    x = height,
    y = fantasyPoints)) +
  geom_point(alpha = 0.05) +
  geom_smooth(
    method = "lm",
    color = "black") +
  geom_smooth() +
  coord_cartesian(
    ylim = c(0,NA),
    expand = FALSE) +
  labs(
    x = "Player Height (Inches)",
    y = "Fantasy Points (Season)",
    title = "Fantasy Points (Season) by Player Height",
    subtitle = "(Among Wide Receivers)"
  ) +
  theme_classic()

ggplot2::ggplot(
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  aes(
    x = weight,
    y = fantasyPoints)) +
  geom_point(alpha = 0.05) +
  geom_smooth(
    method = "lm",
    color = "black") +
  geom_smooth() +
  coord_cartesian(
    ylim = c(0,NA),
    expand = FALSE) +
  labs(
    x = "Player Weight (Pounds)",
    y = "Fantasy Points (Season)",
    title = "Fantasy Points (Season) by Player Weight",
    subtitle = "(Among Wide Receivers)"
  ) +
  theme_classic()

ggplot2::ggplot(
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  aes(
    x = target_share,
    y = fantasyPoints)) +
  geom_point(alpha = 0.05) +
  geom_smooth(
    method = "lm",
    color = "black") +
  geom_smooth() +
  coord_cartesian(
    ylim = c(0,NA),
    expand = FALSE) +
  labs(
    x = "Target Share",
    y = "Fantasy Points (Season)",
    title = "Fantasy Points (Season) by Target Share",
    subtitle = "(Among Wide Receivers)"
  ) +
  theme_classic()
```

There are some suggestions of potential nonlinearity, such as an inverted-U-shaped association between height and fantasy points, suggesting that there may an optimal range for height among Wide Receivers—being too short or too tall could be a disadvantage.
In addition, target share shows a weakening association as target share increases.
Thus, after evaluating the linear association between the predictors and outcome, we will also examine the possibility for curvilinear associations.

First, let's estimate a multiple regression model with only linear terms:

```{r}
linearRegressionModel <- lm(
  fantasyPoints ~ age + height + weight + target_share,
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)
```

Here are the model results:

```{r}
summary(linearRegressionModel)
```

The only terms that are significantly associated with fantasy performance among Wide Receivers are weight and target share, both of which showed a positive association with fantasy points.
If we want to obtain standardized regression coefficients, we can standardize the outcome variable and each predictor variable using the `scale()` function:

```{r}
linearRegressionModelStandardized <- lm(
  scale(fantasyPoints) ~ scale(age) + scale(height) + scale(weight) + scale(target_share),
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)

summary(linearRegressionModelStandardized)
```

Target share has a large [effect size](#sec-practicalSignificance).
All of the other predictors have small effect sizes.

Now let's consider whether any of the terms show curvilinear associations with fantasy points by adding quadratic terms:

```{r}
quadraticTermsRegressionModel <- lm(
  fantasyPoints ~ age + I(age^2) + height + I(height^2) + weight + I(weight^2) + target_share + I(target_share^2),
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)

summary(quadraticTermsRegressionModel)
```

Only the quadratic term for target share shows a significant association.
If we wanted to visualize the shape of the model-implied association between target share and fantasy points, we could generate the model-implied predictions using the data range that we want to visualize.

```{r}
newdata <- data.frame(
  target_share = seq(
    from = min(player_stats_seasonal$target_share[which(player_stats_seasonal$position == "WR")], na.rm = TRUE),
    to = max(player_stats_seasonal$target_share[which(player_stats_seasonal$position == "WR")], na.rm = TRUE),
    length.out = 1000
  )
)

newdata$age <- mean(player_stats_seasonal$age[which(player_stats_seasonal$position == "WR")], na.rm = TRUE)
newdata$height <- mean(player_stats_seasonal$height[which(player_stats_seasonal$position == "WR")], na.rm = TRUE)
newdata$weight <- mean(player_stats_seasonal$weight[which(player_stats_seasonal$position == "WR")], na.rm = TRUE)
```

```{r}
newdata$fantasyPoints <- predict(
  quadraticTermsRegressionModel,
  newdata = newdata
)
```

We can depict the model-implied predictions of fantasy points as a function of target share, as shown in @fig-modelImpliedPredictionsQuadraticRegression.

```{r}
#| label: fig-modelImpliedPredictionsQuadraticRegression
#| fig-cap: "Model-Implied Predictions of A Wide Receiver's Fantasy Points as a Function of Target Share. The model-implied predictions were estimated based on a multiple regression model."
#| fig-alt: "Model-Implied Predictions of A Wide Receiver's Fantasy Points as a Function of Target Share. The model-implied predictions were estimated based on a multiple regression model."

ggplot2::ggplot(
  data = newdata,
  aes(
    x = target_share,
    y = fantasyPoints)) +
  geom_smooth() +
  coord_cartesian(
    ylim = c(0,NA),
    expand = FALSE) +
  labs(
    x = "Target Share",
    y = "Fantasy Points (Season)",
    title = "Fantasy Points (Season) by Target Share",
    subtitle = "(Among Wide Receivers)"
  ) +
  theme_classic()
```

### Evaluating and Addressing Assumptions {#sec-multipleRegressionExamplesAddressingAssumptions}

The assumptions for multiple regression are described in @sec-assumptionsRegression.
I describe ways to evaluate assumptions in @sec-assumptionsRegressionEvaluating.

As a reminder, here are four assumptions:

- there is a linear association between the predictor variables and the outcome variable
- there is homoscedasticity of the residuals; the residuals do not differ as a function of the predictor variables or as a function of the outcome variable
- the residuals are independent; they are uncorrelated with each other
- the residuals are normally distributed

#### Linear Association {#sec-multipleRegressionExamplesAddressingAssumptionsLinearAssociation}

We evaluated the shape of the association between the predictor variables and the outcome variables using scatterplots.
We accounted for potential curvilinearity with a quadratic term.
Other ways to account for nonlinearity, in addition to polynomials (e.g., quadratic, cubic, quartic, or higher-degree terms), include transforming predictors (e.g., log, square root, inverse, exponential transform), splines/piecewise regression, and generalized additive models.

We can also evaluate residual plots (@fig-residualPlots), marginal model plots (@fig-marginalModelPlots), and added-variable plots (@fig-addedVariablePlots) from the `car` package [@Fox2019; @R-car], to evaluate for potential nonlinearity.
For evaluating linearity, we would expect minimal bend/curvature in the lines.

```{r}
#| label: fig-marginalModelPlots
#| fig-cap: "Marginal Model Plots."
#| fig-alt: "Marginal Model Plots."

car::marginalModelPlots(
  quadraticTermsRegressionModel,
  sd = TRUE,
  id = TRUE)
```

```{r}
#| label: fig-addedVariablePlots
#| fig-cap: "Added-Variable Plots."
#| fig-alt: "Added-Variable Plots."

car::avPlots(
  quadraticTermsRegressionModel,
  id = TRUE)
```

The marginal model plots (@fig-marginalModelPlots) and residual plots (@fig-residualPlots) suggest that the nonlinearity of the association between target share and fantasy points may not be fully captured by the quadratic term.
Thus, we may need to apply a different approach to handling the nonlinear association between target share and fantasy points.

One approach we can take is to transform the `target_shares` variable to be more normally distributed.

The histogram for the raw `target_shares` variable is in @fig-histogramTargetShare.

```{r}
#| label: fig-histogramTargetShare
#| fig-cap: "Histogram of Target Share."
#| fig-alt: "Histogram of Target Share."

hist(player_stats_seasonal$target_share[which(player_stats_seasonal$position == "WR")])
```

The variable shows a strong positive skew.
To address a strong positive skew, we can use a log transformation.
The histogram of the log-transformed variable is in @fig-histogramTargetSharesLog.

```{r}
#| label: fig-histogramTargetSharesTransformed
#| fig-cap: "Histogram of Target Share, Transformed."
#| fig-alt: "Histogram of Target Share, Transformed."

hist(log(player_stats_seasonal$target_share[which(player_stats_seasonal$position == "WR")] + 1))
```

Now we can re-fit the model with the log-transformed variable.

```{r}
linearRegressionModel_logTargetShare <- lm(
  fantasyPoints ~ age + I(age^2) + height + I(height^2) + weight + I(weight^2) + I(log(target_share + 1)),
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)

summary(linearRegressionModel_logTargetShare)
```

Target share shows a more linear association with fantasy points after log-transforming it (albeit still not perfect), as depicted in Figures [-@fig-marginalModelPlotsLogTransformed], [-@fig-addedVariablePlotsLogTransformed], and [-@fig-residualPlotsLogTransformed].

```{r}
#| label: fig-marginalModelPlotsLogTransformed
#| fig-cap: "Marginal Model Plots After Log Transformation of Target Share."
#| fig-alt: "Marginal Model Plots After Log Transformation of Target Share."

car::marginalModelPlots(
  linearRegressionModel_logTargetShare,
  sd = TRUE,
  id = TRUE)
```

```{r}
#| label: fig-addedVariablePlotsLogTransformed
#| fig-cap: "Added-Variable Plots After Log Transformation of Target Share."
#| fig-alt: "Added-Variable Plots After Log Transformation of Target Share."

car::avPlots(
  linearRegressionModel_logTargetShare,
  id = TRUE)
```

```{r}
#| label: fig-residualPlotsLogTransformed
#| fig-cap: "Residual Plots After Log Transformation of Target Share."
#| fig-alt: "Residual Plots After Log Transformation of Target Share."

car::residualPlots(
  linearRegressionModel_logTargetShare,
  id = TRUE)
```

#### Homoscedasticity {#sec-multipleRegressionExamplesAddressingAssumptionsHomoscedasticity}

To evaluate homoscedasticity, we can evaluate residual plots (@fig-residualPlots).
In residual plots, you want a constant spread of residuals versus fitted values—you do not want the residuals to show a fan or cone shape.

```{r}
#| label: fig-residualPlots
#| fig-cap: "Residual Plots."
#| fig-alt: "Residual Plots."

car::residualPlots(
  quadraticTermsRegressionModel,
  id = TRUE)
```

In this example, the residuals appear to increase as a function of the fitted values.
To handle this, we may need to transform the outcome variable to be more normally distributed.

The histogram for raw fantasy points is in @fig-histogramFantasyPoints.

```{r}
#| label: fig-histogramFantasyPoints
#| fig-cap: "Histogram of Fantasy Points (Among Wide Receivers)."
#| fig-alt: "Histogram of Fantasy Points (Among Wide Receivers)."

hist(player_stats_seasonal$fantasyPoints[which(player_stats_seasonal$position == "WR")])
```

Let's use a Yeo-Johnson transformation of fantasy points:

```{r}
yjTransformed <- caret::preProcess(
  player_stats_seasonal["fantasyPoints"],
  method = c("YeoJohnson"))

yjTransformed

player_stats_seasonal$fantasyPoints_transformed <- predict(
  yjTransformed,
  newdata = player_stats_seasonal["fantasyPoints"])$fantasyPoints
```

The histogram of the transformed variable is in @fig-histogramFantasyPointsTransformed.

```{r}
#| label: fig-histogramFantasyPointsTransformed
#| fig-cap: "Histogram of Fantasy Points (Among Wide Receivers), Transformed."
#| fig-alt: "Histogram of Fantasy Points (Among Wide Receivers), Transformed."

hist(player_stats_seasonal$fantasyPoints_transformed[which(player_stats_seasonal$position == "WR")])
```

Now we can refit the model.

```{r}
linearRegressionModel_outcomeTransformed <- lm(
  fantasyPoints_transformed ~ age + height + weight + I(log(target_share + 1)),
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)

summary(linearRegressionModel_outcomeTransformed)
```

The residual plots are in @fig-residualPlotsOutcomeTransformed.

```{r}
#| label: fig-residualPlotsOutcomeTransformed
#| fig-cap: "Residual Plots After Transformation of Fantasy Points."
#| fig-alt: "Residual Plots After Transformation of Fantasy Points."

car::residualPlots(
  linearRegressionModel_outcomeTransformed,
  id = TRUE)
```

The residuals show more constant variance after transforming the outcome variable.

#### Uncorrelated Residuals {#sec-multipleRegressionExamplesAddressingAssumptionsUncorrelatedResiduals}

To determine if residuals are correlated given the nested structure of the data, we can examine the proportion of variance that is attributable to the particular player.
To do this, we can estimate the intraclass correlation coefficient (ICC) from a [mixed model](#sec-mixedModels) using the `performance` package [@Ludecke2021; @R-performance].

```{r}
mixedModel <- lmer(
  fantasyPoints_transformed ~ 1 + (1 | player_id),
  data = player_stats_seasonal)

performance::icc(mixedModel)
```

The ICC indicates that over half of the variance is attribute to between-player variance, so it would be important to account for the player-specific variance using a [mixed model](#sec-mixedModels).
For simplicity, we focus on multiple regression models in this chapter; mixed models are described in @sec-mixedModels.

#### Normally Distributed Residuals {#sec-multipleRegressionExamplesAddressingAssumptionsNormallyDistributedResiduals}

We can examine whether residuals are normally distributed using quantile–quantile (QQ) plots and probability–probability (PP) plots, as in Figures [-@fig-qqPlot] and [-@fig-ppPlot].
If the residuals are normally distributed, they should stay close to the diagonal reference line.

```{r}
#| label: fig-qqPlot
#| fig-cap: "Residual Plots After Transformation of Fantasy Points."
#| fig-alt: "Residual Plots After Transformation of Fantasy Points."

car::qqPlot(
  linearRegressionModel_outcomeTransformed,
  main = "QQ Plot",
  id = TRUE)
```


```{r}
#| label: fig-ppPlot
#| fig-cap: "Residual Plots After Transformation of Fantasy Points."
#| fig-alt: "Residual Plots After Transformation of Fantasy Points."

petersenlab::ppPlot(
  linearRegressionModel_outcomeTransformed)
```

## Multicollinearity {#sec-multipleRegressionMulticollinearity}

*Multicollinearity* occurs when two or more [predictor variables](#sec-correlationalStudy) in a regression model are highly correlated.
The problem of having multiple [predictor variables](#sec-correlationalStudy) that are highly correlated is that it makes it challenging to estimate the regression coefficients accurately.

Multicollinearity in multiple regression is depicted conceptually in @fig-regression.

::: {#fig-regression}
![](images/multipleRegressionMulticollinearity.png){width=50% fig-alt="Conceptual Depiction of Multicollinearity in Multiple Regression. From @Petersen2024a and @PetersenPrinciplesPsychAssessment."}

Conceptual Depiction of Multicollinearity in Multiple Regression. From @Petersen2024a and @PetersenPrinciplesPsychAssessment.
:::

Consider the following example adapted from @PetersenPrinciplesPsychAssessment where you have two [predictor variables](#sec-correlationalStudy) and one [outcome variable](#sec-correlationalStudy), as shown in @tbl-regression3.

```{r}
#| echo: false

regression3 <- data.frame(
  "y" = c(9, 11, 17, 3, 21, 13),
  "x1" = c(2, 3, 4, 1, 5, 3.5),
  "x2" = c(4, 6, 8, 2, 10, 7))
```

```{r}
#| label: tbl-regression3
#| tbl-cap: "Example Data of Predictors (x1 and x2) and Outcome (y) Used for Regression Model."
#| echo: false

kable(
  regression3,
  col.names = c("y","x1","x2"),
  booktabs = TRUE)
```

The second [predictor variable](#sec-correlationalStudy) is not very good—it is exactly twice the value of the first [predictor variable](#sec-correlationalStudy); thus, the two [predictor variables](#sec-correlationalStudy) are perfectly correlated (i.e., $r = 1.0$).
This means that there are different prediction equation possibilities that are equally good—see Equations in @eq-multicollinearity:

$$
\begin{aligned}
  2x_2 &= y \\
  0x_1 + 2x_2 &= y \\
  4x_1 &= y \\
  4x_1 + 0x_2 &= y \\
  2x_1 + 1x_2 &= y \\
  5x_1 - 0.5x_2 &= y \\
  ...
&= y
\end{aligned}
$$ {#eq-multicollinearity}

Then, what are the regression coefficients?
We do not know what are the correct regression coefficients because each of the possibilities fits the data equally well.
Thus, when estimating the regression model, we could obtain arbitrary estimates of the regression coefficients with an enormous standard error around each estimate.
In general, multicollinearity increases the uncertainty (i.e., standard errors and confidence intervals) around the parameter estimates.
Any [predictor variables](#sec-correlationalStudy) that have a correlation above ~ $r = .30$ with each other could have an impact on the confidence interval of the regression coefficient.
As the correlations among the [predictor variables](#sec-correlationalStudy) increase, the chance of getting an arbitrary answer increases, sometimes called "bouncing betas."
So, it is important to examine a correlation matrix of the [predictor variables](#sec-correlationalStudy) before putting them in the same regression model.
You can also examine indices such as variance inflation factor (VIF), where a value greater than 5 or 10 indicates multicollinearity.

Here is the VIF from our earlier model:

```{r}
car::vif(linearRegressionModel_outcomeTransformed)
```

To address multicollinearity, you can drop a redundant predictor or you can also use principal component analysis or factor analysis of the predictors to reduce the predictors down to a smaller number of meaningful predictors.
For a meaningful answer in a regression framework that is precise and confident, you need a low level of intercorrelation among predictors, unless you have a very large sample size.

## Handling of Missing Data {#sec-multipleRegressionMissingness}

An important consideration in multiple regression is how missing data are handled.
Multiple regression in `R` using the `lm()` function applies listwise deletion.
*Listwise deletion* removes any row (in the data file) from analysis that has a missing value on the [outcome variable](#sec-correlationalStudy) or any of the [predictor variables](#sec-correlationalStudy).
Removing all rows from analysis that have any missingness in the model variables can be a problem because missingness is often not completely at random—missingness often occurs systematically (i.e., for a reason).
For instance, participants may be less likely to have data for all variables if they are from a lower socioeconomic status background and do not have the time to participate in all study procedures.
Thus, applying listwise deletion, we might systematically exclude participants from lower socioeconomic status backgrounds (or other groups), which could lead to less generalizable inferences.

It is thus important to consider approaches to handle missingness.
Various approaches to handle missingness include pairwise deletion (aka available-case analysis), multiple imputation, and full information maximum likelihood (FIML).

### Pairwise Deletion {#sec-multipleRegressionPairwiseDeletion}

We can estimate a regression model that uses pairwise deletion using the `lavaan` package [@Rosseel2012; @R-lavaan].

```{r}
player_stats_seasonal$target_share_log <- log(player_stats_seasonal$target_share + 1)

modelData <- player_stats_seasonal %>% 
  filter(position %in% c("WR")) %>% 
  select(fantasyPoints_transformed, age, height, weight, target_share_log)

numObs <- sum(complete.cases(modelData))
varMeans <- colMeans(modelData, na.rm = TRUE)
varCovariances <- cov(modelData, use = "pairwise.complete.obs")

pairwiseRegression_syntax <- '
  fantasyPoints_transformed ~ age + height + weight + target_share_log
  fantasyPoints_transformed ~~ fantasyPoints_transformed
  fantasyPoints_transformed ~ 1
'

pairwiseRegression_fit <- lavaan::lavaan(
  pairwiseRegression_syntax,
  sample.mean = varMeans,
  sample.cov = varCovariances,
  sample.nobs = numObs
)

summary(
  pairwiseRegression_fit,
  standardized = TRUE,
  rsquare = TRUE)
```

### Multiple Imputation {#sec-multipleRegressionMultipleImputation}

We can multiply impute data using the `mice` package [@vanBuuren2011; @R-mice].

```{r}
numImputations <- 5

dataToImpute <- player_stats_seasonal %>% 
  filter(position %in% c("WR")) %>% 
  select(player_id, where(is.numeric)) %>% 
  select(
    player_id:games, carries:wopr, fantasy_points, fantasy_points_ppr,
    rush_40_yds, rec_40_yds, fumbles, two_pts, return_yds,
    rush_100_yds:draftround, height:target_share_log) %>% 
  select(-c(fantasy_points_ppr, ageCentered20, target_share_log)) # drop collinear variables

predictors <- c("targets","receiving_yards","receiving_air_yards","receiving_yards_after_catch","receiving_first_downs","racr")

dataToImpute$player_id_integer <- as.integer(as.factor(dataToImpute$player_id))

varsToImpute <- c("age","height","weight","target_share")
Y <- varsToImpute
```

Now, let's specify the imputation method—we use the two-level predictive mean matching (`2l.pmm`) method from the `miceadds` package [@R-miceadds] to account for the nonindependent data (owing to multiple seasons per player):

```{r}
meth <- make.method(dataToImpute)
meth[1:length(meth)] <- ""
meth[Y] <- "2l.pmm" # specify the imputation method here; this can differ by outcome variable
```

Now, let's specify the prediction matrix.
A predictor matrix is a matrix of values, where:

- columns with non-zero values are predictors of the variable specified in the given row
- the diagonal of the predictor matrix should be zero because a variable cannot predict itself

The values are:

- NOT a predictor of the outcome: `0`
- cluster variable: `-2`
- fixed effect of predictor: `1`
- fixed effect and random effect of predictor: `2`
- include cluster mean of predictor in addition to fixed effect of predictor: `3`
- include cluster mean of predictor in addition to fixed effect and random effect of predictor: `4`

```{r}
pred <- make.predictorMatrix(dataToImpute)
pred[1:nrow(pred), 1:ncol(pred)] <- 0
pred[Y, "player_id_integer"] <- (-2) # cluster variable
pred[Y, predictors] <- 1 # fixed effect predictors
pred[Y, "age"] <- 2 # random effect predictor
pred[Y, Y] <- 1 # fixed effect predictor

diag(pred) <- 0
```

Now, let's run the imputation:

```{r}
#| output: false

imp <- mice::mice(
  as.data.frame(dataToImpute),
  method = meth,
  predictorMatrix = pred,
  m = numImputations,
  maxit = 5, # generally use 100 maximum iterations; this example uses 5 for speed
  seed = 52242)
```

Below are some imputation diagnostics.
Trace plots are in @fig-miTracePlots.

```{r}
#| label: fig-miTracePlots
#| fig-cap: "Trace plots from multiple imputation."
#| fig-alt: "Trace plots from multiple imputation."

plot(imp, c("target_share"))
```

A density plot is in @fig-miDensityPlot.

```{r}
#| label: fig-miDensityPlot
#| fig-cap: "Density plot from multiple imputation."
#| fig-alt: "Density plot from multiple imputation."

densityplot(imp, ~ target_share)
```

The imputated data does not match well the distribution of the observed data.
Thus, it may be necessary to select a different imputation method for more accurate imputation.

Now, let's do some post-processing:

```{r}
imp_long <- complete(
  imp,
  action = "long",
  include = TRUE)

imp_long$target_share_log <- log(imp_long$target_share + 1)

imp_long$fantasyPoints_transformed <- predict(
  yjTransformed,
  newdata = imp_long["fantasyPoints"])$fantasyPoints

imp_mids <- as.mids(imp_long)
```

Now let's estimate multiple regression with the multiply imputed data:

```{r}
imp_regression <- with(
  imp_mids,
  lm(
    fantasyPoints_transformed ~ age + height + weight + target_share_log)
  )

summary(pool(imp_regression))
```

### Full Information Maximum Likelihood {#sec-multipleRegressionFIML}

We can estimate a regression model that uses full information maximum likelihood using the `lavaan` package [@Rosseel2012; @R-lavaan].

```{r}
fimlRegression_syntax <- '
  fantasyPoints_transformed ~ age + height + weight + target_share_log
  fantasyPoints_transformed ~~ fantasyPoints_transformed
  fantasyPoints_transformed ~ 1
'

fimlRegression_fit <- sem(
  fimlRegression_syntax,
  data = player_stats_seasonal,
  missing = "ML",
  fixed.x = FALSE
)

summary(
  fimlRegression_fit,
  standardized = TRUE,
  rsquare = TRUE)
```

## Addressing Non-Independence of Observations {#sec-multipleRegressionNonIndependence}

Please note that the $p$-value for regression coefficients assumes that the observations are independent—in particular, that the residuals are not correlated.
However, the observations are not independent in the `player_stats_seasonal` dataframe used above, because the same player has multiple rows—one row corresponding to each season they played.
This non-independence violates the traditional assumptions of the significance of regression coefficients.
We could address this assumption by analyzing only one season from each player or by estimating the significance of the regression coefficients using cluster-robust standard errors.
For simplicity in the models above, we present results above from the whole dataframe.
In @sec-mixedModels, we discuss [mixed model](#sec-mixedModels) approaches that handle repeated measures and other data that violate assumptions of non-independence.
Below, we demonstrate how to account for non-independence of observations using cluster-robust standard errors with the `rms` package [@R-rms].

```{r}
player_stats_seasonal_subset <- player_stats_seasonal %>% 
  filter(!is.na(player_id))

rms::robcov(rms::ols(
  fantasyPoints_transformed ~ age + height + weight + target_share_log,
  data = player_stats_seasonal_subset,
  x = TRUE,
  y = TRUE),
  cluster = player_stats_seasonal_subset$player_id) #account for nested data within player
```

## Impact of Outliers {#sec-multipleRegressionOutliers}

[As with correlation](#sec-correlationOutliers), multiple regression can be strongly impacted by outliers.

## Moderated Multiple Regression {#sec-moderatedMultipleRegression}

When examining moderation in multiple regression, several steps are important:

- When computing the interaction term, first mean-center the predictor variables.
Calculate the interaction term as the multiplication of the mean-centered predictor variables.
Mean-centering the predictor variables when computing the interaction term is important for addressing issues regarding [multicollinearity](#sec-multipleRegressionMulticollinearity) [@Iacobucci2016].
- When including an interaction term in the model, make sure also to include the main effects.

First, we mean-center the predictors.
In this case, we center the predictors around the mean of height and weight for Wide Receivers:

```{r}
player_stats_seasonal$height_centered <- player_stats_seasonal$height - mean(player_stats_seasonal$height[which(player_stats_seasonal$position == "WR")], na.rm = TRUE)
player_stats_seasonal$weight_centered <- player_stats_seasonal$weight - mean(player_stats_seasonal$weight[which(player_stats_seasonal$position == "WR")], na.rm = TRUE)
```

Then, we compute the interaction term as the multiplication of the two centered predictors:

```{r}
player_stats_seasonal$heightXweight <- player_stats_seasonal$height_centered * player_stats_seasonal$weight_centered
```

Then, we fit the moderated multiple regression model:

```{r}
moderationModel <- lm(
  fantasyPoints_transformed ~ height_centered + weight_centered + height_centered:weight_centered,
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)

summary(moderationModel)
```

This model is equivalent to the model that includes the interaction term explicitly:

```{r}
#| eval: false

moderationModel <- lm(
  fantasyPoints_transformed ~ height_centered + weight_centered + heightXweight,
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  na.action = "na.exclude"
)

summary(moderationModel)
```

Now, we can visualize the interaction to understand it.
We create an interaction plot (@fig-interactionPlot) and Johnson-Neyman plot (@fig-johnsonNeymanPlot) using the `interactions` package [@R-interactions].

```{r}
#| label: fig-interactionPlot
#| fig-cap: "Interaction Plot from Moderated Multiple Regression."
#| fig-alt: "Interaction Plot from Moderated Multiple Regression."

interactions::interact_plot(
  moderationModel,
  pred = height_centered,
  modx = weight_centered)
```

```{r}
#| label: fig-johnsonNeymanPlot
#| fig-cap: "Johnson-Neyman Plot from Moderated Multiple Regression."
#| fig-alt: "Johnson-Neyman Plot from Moderated Multiple Regression."

interactions::johnson_neyman(
  moderationModel,
  pred = height_centered,
  modx = weight_centered,
  alpha = .05)
```

Here is a simple slopes analysis:

```{r}
interactions::sim_slopes(
  moderationModel,
  pred = height_centered,
  modx = weight_centered,
  johnson_neyman = FALSE)
```

## Mediation {#sec-multipleRegressionMediation}

## Bayesian Multiple Regression {#sec-multipleRegressionBayesian}

```{r}
bayesianMultipleRegressionModel <- brm(
  formula = fantasyPoints_transformed ~ age + height + weight + I(log(target_share + 1)),
  data = player_stats_seasonal %>% filter(position %in% c("WR")),
  family = gaussian()
)

summary(bayesianMultipleRegressionModel)
```

## Conclusion {#sec-multipleRegressionConclusion}

Multiple regression allows examining the association between multiple [predictor variables](#sec-correlationalStudy) and one [outcome variable](#sec-correlationalStudy).
Inclusion of multiple predictors in the model allows for potentially greater predictive accuracy and identification of the extent to which each variable uniquely contributes to the outcome variable.
As with [correlation](#sec-correlation), an association does not imply causation.
However, identifying associations is important because associations are a necessary (but insufficient) condition for causality.
When developing a multiple regression model, it is important to pay attention for potential [multicollinearity](#sec-multipleRegressionMulticollinearity)—it may become difficult to detect a given [predictor variable](#sec-correlationalStudy) as [statistically significant](#sec-statisticalSignificance) due to the greater uncertainty around the parameter estimates.

::: {.content-visible when-format="html"}

## Session Info {#sec-multipleRegressionSessionInfo}

```{r}
sessionInfo()
```

:::
